#include <iostream>
using namespace std;

class myobject{
private:
	char* name;
public:
	myobject(char* p)
	{
		name = new char[::strlen(p)+1];   //malloc
		::strcpy(name,p);
		cout<<"inside The constructor. my name is "<< name << endl;
	} 
	~myobject()
	{	
		cout<<"inside The destructor. my name is "<< name << endl;
        delete[] name;
	}
};


myobject a1("a1");//global object
static myobject a2("a2");//static global object

int main() 
{
	cout << "after the first opening brace of main()" << endl;
	
	myobject a3("a3");// local object
	
	cout << "before opening brace" << endl;
	{
		myobject a4("a4");//local object
		cout << "before closing brace" << endl;
	}
	
	cout << "after closing brace" << endl;

	void f();
	void g();

	f();
	g();
	f();
	g();
	
	getchar();

	return 0;
} 


void f()
{
     myobject m("m");
}

void g()
{
	static int f = 10;
	static myobject m("m");
}

/*
C++中事实：在main执行前和执行后都有大量代码被执行。尤其是，
静态的类对象和定义在全局的、命名空间中的或文件体中的类对象的
构造函数通常在main被执行前就被调用。
这个过程称为静态初始化。这和我们对C++和C程序的通常认识相反，
我们一直把main当作程序的入口。同样，通过静态初始化产生的对象
也要在静态析构过程中调用其析构函数；这个过程通常发生在main
结束运行之后。
为了解决main()应该首先被调用，而对象又需要在main()执行前被构造的
两难问题，许多编译器在main()的最开始处插入了一个特别的函数，
由它来负责静态初始化。同样地，编译器在main()结束处插入了一个函数
来析构静态对象。产生的代码通常看起来象这样：
int main(int argc, char *argv[])
{
  performStaticInitialization();         // generated by the
                                         // implementation
  the statements you put in main go here;

  performStaticDestruction();            // generated by the
                                         // implementation
}

*/ 
