1)function template
  //a.cpp
  template <class T> 
  inline T Max(T x,T y)
  {
	return (x>y)?x:y;
  }
  
  //b.cpp
#include <iostream>
using namespace std;

template <typename T> inline T Max(T x,T y);
void main()
{
  cout << Max(3,4);   //link-error
}


2)C++ template中typename 和class有什么区别? 
class用于定义类，在模板引入c++后，最初定义模板的方法为： template<class T>...... 
在这里class关键字表明T是一个类型，后来为了避免class在这两个地方的使用可能给人带来混淆，所以引入了typename这个关键字，它的作用同class一样表明后面的符号为一个类型，这样在定义模板的时候就可以使用下面的方式了： 
template<typename T>......
在模板定义语法中关键字class与typename的作用完全一样。
typename另外一个作用为：使用嵌套依赖类型(nested depended name)，如下所示：
class MyArray 
{ 
public：
     typedef int LengthType;
.....
}

template<class T>
void MyMethod( T myarr ) 
{ 
    typedef typename T::LengthType LengthType; 
    LengthType length = myarr.GetLength; 
}

这个时候typename的作用就是告诉c++编译器，typename后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有typename，编译器没有任何办法知道T::LengthType是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。 


2019.1.3 page10
2)class template

#include "iostream"
#include <memory.h>
#include <process.h>
using namespace std;

class array{  
public:  
	array(int size1=10):size(size1),p(new int[size1])
	{ 
		memset(p, 0, size*sizeof(int));
		cout << "I am in array(int size1)." << endl;
	}
	~array() 
	{  
		delete[] p;  
		cout << "I am in ~array()." << endl;
	}
	int& operator[](int i) 	
	{   
		if(i<0 || i>=size) 
		{
		   cout<<"下标越界！"<<endl;
		   exit(1);  
		}
		return p[i];
	}
	int operator[](int i) const	
	{   
		if(i<0 || i>=size) 
		{
		   cout<<"下标越界！"<<endl;
		   exit(1);  
		}
		return p[i];
	}
	int getsize() const
	{
		return size;
	}
	friend istream& operator>>(istream& in,array<T>& ob);	
	friend ostream& operator<<(ostream& out,const array<T>& ob);
private:  
	int *p;
        int size;
	array(const array&);
	array& operator=(const array&);
};

istream& operator>>(istream& in, array<int>& ob)
{
   for(int i=0; i<ob.getsize(); i++)
	   in >> ob[i];

   return in;   
}

ostream& operator<<(ostream& out, const array<int>& ob)
{
	for (int i=0; i<ob.getsize(); i++)
		out << ob[i] << ","; 

	out << endl;
	return out;
}

void main()
{
	array a(10),c;
 	for(int i=0;i < a.getsize();i++)
		a[i] = i;	 

	cout << a << endl;
	cout << c << endl;
	system("pause");
 }
templatizing

#include "iostream"
#include <memory.h>
#include <process.h>
using namespace std;

template <typename T>
class array{  
public:  
	array(int size1=10):size(size1),p(new T[size1])
	{ 
		memset(p, 0, size*sizeof(T));
		cout << "I am in array(int size1)." << endl;
	}
	~array() 
	{  
		delete[] p;  
		cout << "I am in ~array()." << endl;
	}
	T& operator[](int i) 	
	{   
		if(i<0 || i>=size) 
		{
		   cout<<"下标越界！"<<endl;
		   exit(1);  
		}
		return p[i];
	}
	T operator[](int i) const	
	{   
		if(i<0 || i>=size) 
		{
		   cout<<"下标越界！"<<endl;
		   exit(1);  
		}
		return p[i];
	}
	T getsize() const
	{
		return size;
	}
	friend istream& operator>>(istream& in,array<T>& ob);	
	friend ostream& operator<<(ostream& out,const array<T>& ob);
private:  
	T *p;
        int size;
	array(const array&);
	array& operator=(const array&);
};

istream& operator>>(istream& in, array<T>& ob)
{
   for(int i=0; i<ob.getsize(); i++)
	   in >> ob[i];

   return in;   
}

ostream& operator<<(ostream& out, const array<T>& ob)
{
	for (int i=0; i<ob.getsize(); i++)
		out << ob[i] << ","; 

	out << endl;
	return out;
}

void main()
{
	array<int> a(10),c;
 	for(int i=0;i < a.getsize();i++)
		a[i] = i;	 

	cout << a << endl;
	cout << c << endl;
	system("pause");
 }



3)  int a, b;
    cin >> a >> b;
    cout >> a/b;   exception
 

6)review
  review/MyObject.h MyObject.cpp 试题分析.cpp
  
7)指向全局函数的指针
  int (*fp)(float);
  fp is a pointer to a function,this function has a float parameter and return int value

  指向成员函数的指针
  返回值类型 (类名::*指针变量名)(参数列表);

  class Shape {    
   public:      //...      
               void moveTo( Point newLocation );      
               bool validate() const;      
               virtual bool draw() const = 0;      
   //...  };  

  class Circle : public Shape { 
   public:
               bool draw() const;      
   //...  };  

   void (Shape::*mf1)( Point );
   mf1 = Shape::moveTo; 

   bool (Shape::*mf2)() const;
   mf2 = Shape::draw; 

   Circle circ;  
   Shape *pShape = &circ;  
   (pShape->*mf2)(); // 调用Circle::draw  动态binding  
   (circ.*mf2)(); // 调用Circle::draw 

8)设计类
  是一个对象的私有财产--->类的私有成员（private data member/private member function）
  是相同属性对象的共同财产--->类的静态成员(private static data / public static function)
  class student{
  private:
         int num;
         char *name;
         int age;
         static int bursary;
         int 积分计算();
  public:
         student(int n, char *p, int a): num(n),p(new char[sizeof(p)+1]), age(a)
         {}
         virtual ~student() {  delete[] name;  }
         static int select_bursary();
         static int apply_bursary(int i);

         void study(){//...}
  };

  int student::bursary = 10000;

  int sudent::select_bursary()
  {
       return bursary;
  }
    
  int apply_bursary(int i)
  {
       bursary -= i;
  }

  void main()
  {
     cout << student::select_bursary();  //不需要创建学生对象
  }



 


